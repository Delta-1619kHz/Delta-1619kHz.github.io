{"posts":[{"title":"[美赛]算法集合","content":"线性、非线性 静态、动态 整数、非整数 随机、非随机 #最优化数学模型分类 线性规划(LP):目标函数和决策变量均为线性 非线性规划(NLP) 二次规划(QP):次数项不止一个 整数规划(IP):决策变量为整数 0-1规划:决策变量仅取值0或1的特殊整数规划 多目标规划:目标函数多于一个 动态规划:规划过程分段 线性规划模型 决策变量 约束条件 目标函数 min c'x x∈Rn s.t. Ax &lt;= b Aeq·x = beq VLB &lt;= x &lt;= VUB b, c, x, beq, VLB, VUB为列矩阵 Matlab: x = linprog(c, A, b, Aeq, beq, VLB, VUB) x最优解，c目标函数，A、b不等式约束，Aeq，beq等式约束，VLB，VUB决策变量上下界 无等式约束，输入[] [x, fval, exitflag, output] = linprog(c, A, b, Aeq, beq, VLB, VUB) fval最优值 exitflag有三种情况，&gt;0收敛，=0到最大迭代次数时都还未收敛，&lt;0infeasible或方法失败 插值与拟合 插值方法： 拉格朗日插值(lagrange插值) 分段线性插值 Hermite 三次样条插值 Kriging:地理常用插值 反距离权重插值:地理常用插值 Matlab: interp1(一维插值)： interp1(x, y, xix_ixi​, 'method') x样本点(x单调)，y样本值，xix_ixi​查询点 'method': 'nearest' 最临近插值 'linear' 线性插值 'spline' 三次样条插值 'cubic' 立方插值 缺省时 分段线性插值 三次样条插值较多 interp2(二维): interp2(x0x_0x0​, y0y_0y0​, z0z_0z0​, x, y, 'method') 'method': 'nearest' 最临近插值 'linear' 双线性插值 'cubic' 双三次插值 缺省时 双线性插值 griddata(散点数据插值): griddata(x, y, z, cx, cy, 'method') cx, cy需为网格点: [cx, cy] = meshgrid(cx, cy) 'method': 'nearest' 最邻近插值 'linear' 双线性插值 'cubic' 双三次插值 'v4' - MatLab提供的插值方法 缺省时 双线性插值 interp3(三维) intern(n维) 拟合方法 直线拟合 y = ax+b 曲线拟合 y = a*e^(bt) -&gt; lny = lna + bx 线性最小二乘法： 选定个数为m的函数组，a1a_1a1​,a2a_2a2​,...,ama_mam​为各项系数 使n个点与曲线的距离平方和最小 MatLab: a = polyfit(x, y, m) m拟合次数 y = polyval(a, x) x处值 非线性规划模型 0-1规划问题 Max(Min)z=c1x1+c2x2+...+cnxMax(Min)z = c_1x_1+c_2x_2+...+c_nx Max(Min)z=c1​x1​+c2​x2​+...+cn​x a11x1a_{11}x_1a11​x1​+a12x2a_{12}x_{2}a12​x2​+...+a1nxna_{1n}x_na1n​xn​&lt;=(&gt;=,=)b1b_1b1​ ...... am1x1a_{m1}x_1am1​x1​+am2x2a_{m2}x_2am2​x2​+...+amnxna_{mn}x_namn​xn​&lt;=(&gt;=,=)bmb_mbm​ x1x_1x1​,x2x_2x2​,...,xnx_nxn​=0|1 ∑j=14xij=1,∑i=15xij=1\\sum_{j=1}^{4} x_{ij}=1,\\sum_{i=1}^{5} x_{ij} =1 j=1∑4​xij​=1,i=1∑5​xij​=1 动态规划 将变量拆分x=x1x_1x1​+x2x_2x2​+x3x_3x3​ LINGO:矩阵赋值不能赋一部分 灰色预测模型 样本较少，小规模预测 数列预测 灾变与异常值预测 拓扑预测 系统预测 数据预处理:对原始数据序列进行累加得到新序列，一次累加简称一次累加生成，逐层累减得原序列 建模:原序列x0x_0x0​，设x1x_1x1​满足dx1x_1x1​/dt +ax1x_1x1​ = u，a为常数，u为发展灰数，为内生控制灰数，是对系统的常定输入，此方程满足x1(t)x_1(t)x1​(t) = [x1(t0)x_1(t0)x1​(t0) - u/a]e^(-a(t-t0t_0t0​)) + u/a，对等间隔的离散值(t0t_0t0​=1)满足x1x_1x1​(k+1) = [x1x_1x1​(1) - u/a]e^(-ak) +u/a，然后通过最小二乘法估计a，u(方程数不大于20)，x1x_1x1​(1)留作初值，x1x_1x1​(2)，x1x_1x1​(3)，...，x1x_1x1​(N)带入方程，用差分代替微分 精度检验:残差检验、后验差检验 建模步骤简述: 人工神经网络(ANN) 拟合 -&gt; 预测 分类 -&gt; 聚类分析 评价 一定要大数据量 建立和应用 网络结构的确定:包含网络的拓扑结构和每个神经元相应函数的选取 权值和阈值的确定:通过学习得到，为有指导的学习，也就是利用已知的一组正确的输入、输出数据，调整权和阈值使得网络输出和理想输出偏差尽量小(权值:构建连接关系的参数，阈值:激活程度) 工作阶段:用带有确定权重和阈值的神经网络解决实际问题的过程，也叫模拟 多输入单输出 输入输出关系: 净激活量 neti=∑j=1nwijxj−θnet_i = \\sum_{j=1}^{n} w_{ij}x_j - θ neti​=j=1∑n​wij​xj​−θ yiy_iyi​ = f(netinet_ineti​) 激活函数 用X表示输入向量，用W表示权重向量: X = [x0x_0x0​, x1x_1x1​, x2x_2x2​, ..., xnx_nxn​], W = [wi0w_{i0}wi0​, wi1w_{i1}wi1​, wi2w_{i2}wi2​, ..., winw_{in}win​]' 则netinet_ineti​ = XW yiy_iyi​ = f(XW) 激活函数: 输入数据和期望值之间可能不是一个量级，故需激活 线性函数:f(x) = kx + c S形函数:f(x) = 1/(1+e^(-αx)) 双极S形函数 f(x) = 2/(1+e^(-αx)) -1 阈值函数: f(x) = {T,x&gt;c;kx,|x|&lt;=c;-T,x&lt;-c} 网络模型 前馈神经网络:只在训练过程中有反馈，分类过程中数据只能向前传送，训练快 反馈神经网络:从输出到输入具有反馈连接的神经网络，训练越来越快，单结构别前馈网络要复杂得多 自组织网络:通过自动寻找样本中的内在规律和本质属性，自组织、自适应地改变网络参数与结构，典型为SOM 工作状态 学习过程:调整连接权重，使得网络输出更符合实际，使得θ-f(XW)导数为0 工作过程:连接权值不变，可作为分类器或预测数据之用 学习方式 有导师学习:将一组训练集送入网络，根据网络的实际输出与期望输出的差别来调整连接权值，如:BP算法 无导师学习:抽取样本集合中蕴含的统计特性，并以神经元之间的连接权的形式存于网络中，如:Hebb学习率 BP神经网络 采用BP学习算法的前馈神经网络 BP算法基本原理:利用输出后的误差来估计输出层的直接前导层的误差，再利用这个误差估计更前一层的误差，如此一层一层的反传下去，就获得了所有其它各层的误差估计 -&gt;信号的正向传播和误差的反向传播 符号定义 输入函数:x = [x1x_1x1​, x2x_2x2​, ..., xnx_nxn​] 隐含层输入向量:hih_ihi​ = [hi1h_{i1}hi1​, hi2h_{i2}hi2​, ..., hiph_{ip}hip​] 隐含层输出向量:hoh_oho​ = [ho1h_{o1}ho1​, ho2h_{o2}ho2​, ..., hoph_{op}hop​] 输出层输入向量:yiy_iyi​ = [yi1y_{i1}yi1​, yi2y_{i2}yi2​, ..., yiqy_{iq}yiq​] 输出层输出向量:yoy_oyo​ = [yo1y_{o1}yo1​, yo2y_{o2}yo2​, ..., yoqy_{oq}yoq​] 期望输出向量:dod_odo​ = [d1d_1d1​, d2d_2d2​, ..., dqd_qdq​] 误差函数: e=12∑o=1q(do(k)−yoo(k))2e =\\frac{1}{2}\\sum_{o = 1}^{q} (d_o(k) - yo_o(k))^2 e=21​o=1∑q​(do​(k)−yoo​(k))2 训练: 通常采用Sigmoid转换函数 生成BP网络: net = newff(PR, [S1 S2 ... SNl], {TF1 TF2 ... TFNl}, BTF) PR:由R维的输入样本最小最大值构成的R*2维矩阵 [S1 S2 ... SNl]各层的神经元个数(隐层神经元个数一般为输入层神经元2~3倍) {TF1 TF2 ... TFNl}各层的神经元传递函数 BTF训练用的函数名称 网络训练: net = train(net, P, T) P标准输入，T标准输出 网络仿真: Y2 = sim(net, P2) 蒙特卡洛方法 统计模拟法、随机抽样技术 优点: 能够比较逼真地描述具有随机性质的事物的特点及物理实验过程 受集合条件限制小 收敛速度与问题的维数无关 具有同时计算多个方案与多个未知量的能力 误差容易确定 程序结构简单，易于实现 缺点: 收敛速度慢 误差具有概率性 在例子运输问题中，计算结果与系统大小有关 产生随机数 随机数表方法:占用很大内存，不适于在计算机上使用 物理方法:放射性物质的放射性或计算机的固有噪声 层次分析法(AHP) 将定性问题定量化 不足: 只能从现有方案中选择出较优，不能提供出一个新的或是更好的方案 该方法的比较、判断以及结果都是比较粗略的，并不适合精确的计算 建立层次结构及成对比较矩阵，人的主观因素起很大作用，无法克服(可让多个专家来作出判断，或以调查问卷方式得出比较阵) 基本步骤: 建立层次结构模型:一般为三层，最上面为目标层，最下面为方案层，中间为准则层或指标层(上层对下层有支配作用；同一层因素不存在支配关系；每层因素一般不要超过9个) 构建成对比较阵:如果决策人对n个因素重要性具有逻辑的绝对一致性，即aija_{ij}aij​·ajka_{jk}ajk​ = aika_{ik}aik​，就称该矩阵为一致矩阵 一致性检验:不一致性不是很严重是可以接受的。1、计算一致性指标CI用来衡量矩阵A的不一致程度CI = (λmaxλ_maxλm​ax - n)/(n -1) 2、查找相应的平均随机一致性指标RI 3、计算一致性比例CR = CI/RI，当CR &lt; 0.1时，矩阵A不一致性可以接受 计算权重向量:将矩阵A最大特征值所对应的向量进行归一化作为权向量 层次总排序求各方案综合得分:将方案权向量与准则层权向量相乘 粒子群算法(PSO) 群体迭代，粒子在解空间追随最优的粒子进行搜索 优点: 简单易行 收敛速度快 设置参数少 构成要素: 群体大小m，整型参数5~10 权重因子:惯性因子ω，学习因子c1c_1c1​，c2c_2c2​(ω=1为基本粒子群算法，ω=0失去粒子本身的速度记忆，c1c_1c1​=0为无私型粒子群算法，c2c_2c2​=0为自我认识型粒子群算法，c1c_1c1​、c2c_2c2​都不为0为完全性粒子群算法) 最大速度:维护算法的探索能力与开发能力的平衡，VmV_mVm​较大，探索能力较强，但容易飞过最优解，VmV_mVm​较小，开发能力较强，但容易陷入局部最优；VmV_mVm​一般设为每维变化范围的10%~20% 邻域的拓扑结构:一种是将群体内所有个体都作为粒子的邻域；另一种是只将群体中的部分个体作为粒子的领域 停止准则:最大迭代步数；可接受的满意解 粒子空间的初始化 惯性权重: w=wmax−(wmax−wmin)∗run/runmaxw = w_{max} - (w_{max} - w_{min}) * run/run_{max} w=wmax​−(wmax​−wmin​)∗run/runmax​ wmax最大惯性权重，wmin最小惯性权重，run当前迭代次数，runmax为算法迭代总次数；较大的w有较好的全局收敛能力，较小的w则有较强的局部收敛能力。因此，随着迭代次数的增加，惯性权重w应不断减少，从而使得粒子群算法在初期具有较强的收敛能力，而王琦具有较强的局部收敛能力 收缩因子法 求最优解: D维空间中，有N个粒子； 粒子i位置:xix_ixi​ = (xi1x_{i1}xi1​, xi2x_{i2}xi2​, ..., xidx_{id}xid​)， 将xix_ixi​带入适应函数f(xix_ixi​)求适应值； 粒子i速度viv_ivi​ = (vi1v_{i1}vi1​, vi2v_{i2}vi2​, ..., vidv_{id}vid​) 粒子i个体经历过的最好位置:pbestipbest_ipbesti​ = (pi1p_i1pi​1, pi2p_i2pi​2, ..., pidp_idpi​d) 种群所经历过的最好位置: gbest = (g1g_1g1​, g2g_2g2​, ..., gdg_dgd​) 通常，在第d(1&lt;=d&lt;=D)维的位置变化范围限定在[Xmin,dX_{min,d}Xmin,d​, Xmax,dX_{max,d}Xmax,d​]内， 速度变化范围限定在[-Vmax,dV_{max,d}Vmax,d​, Vmax,dV_{max,d}Vmax,d​]内 流程: Initial:初始化粒子群体(群体规模为n)，包括随机位置和速度 Evalution:根据fitness function，评价每个粒子的适应度 Find the Pbest:对每个粒子，将其当前适应值与个体历史最佳位置(pbest)对应的适应值作比较，如果当前的适应值更高，则将用当前位置更新历史最佳位置pbest Find the Gbest:对每个粒子，将其适应值与全局最佳位置(gbest)对应的适应值作比较，如果当前适应值更高，则将用当前粒子的位置更新全局最佳位置gbest Update the Velocity:根据公式更新每个粒子的速度与位置 如未满足结束条件，则返回步骤2，通常算法达到最大迭代次数Gmax或最佳适应度值的增量小于某个给定给的阈值时算法停止 遗传算法 优点: 良好的并行性 强大的通用性 良好的全局优化性和良好的鲁棒性 良好的可操作性 缺点: 未成熟的收敛问题 收敛速度慢，算法实时性欠佳 概念 个体 种群 适应度 编码:将一个待求解问题的实际可行解从其解空间转换到遗传算法所能处理的搜索空间(即个体空间)的过程，是遗传算法解决问题的先决条件和关键步骤，主要有二进制编码、浮点数编码，二进制编码比浮点数编码搜索能力强，但浮点数编码比二进制编码在变异操作上能保持更好的种群多样性 解码:将遗传算法所搜索到的最优个体的染色体转换成待求解问题的实际最优解的过程 选择操作:根据各个个体的适应度，按照一定的规则，从第t代群体P(t)中选择出一些优良的个体遗传到下一代群体P(t+1)中。一般地，选择操作通过选择算子进行 交叉操作:将群体P(t)内的各个个体随机搭配成对，对每一对个体，以某个概率(交叉概率)遵照某一种规则交换它们之间的部分染色体 变异操作:对群体P(t)中的每一个个体，以某一概率(变异概率)改变某一个或某一些基因座上的基因值为其它的等位基因 步骤: 确定决策变量及各种约束条件，即确定出个体的表现型X和问题的解空间 建立优化模型，确定出目标函数的类型及其函数描述形式或量化方法 确定表示可行解的染色体解码方法，即确定出个体的基因型X*，及遗传算法的搜索空间 确定解码方式，即确定出由个体基因型X*，到个体表现型X的对应关系和转换方法 确定个体适应度的量化评价方法，就是确定出由目标函数值到个体适应度的转化规则。标准遗传算法的适应度函数常用:直接以待求解的目标函数为适应度函数(简单直观，但可能不满足非负的要求，某些待求解的函数值分布相差很大，由此得到的平均适应度可能不利于体现种群的平均性能)；界限构造法(第一种方法的改进，但有时存在界限值预先难以估计或估计不精准等问题)；倒数法 确定各遗传具体操作方法:1、选择算子和选择操作:常用方法有按比例的适应度分配(选择的蒙特卡洛方法，利用比例于各个个体适应度的概率决定其子孙的遗留可能性)和基于排序的适应度分配(在基于排序的适应度分配中，种群按目标值进行排序。适应度仅仅取决于个体在种群中的序位，而不是实际的目标值，比比例方法表现出更好的鲁棒性)；常用的选择算法有轮盘赌选择法、随机遍历抽样法、局部选择法、截断选择法、锦标赛选择法，提高遗传算法性能的选择方法有稳态繁殖(在迭代过程中用部分优质新个体来更新群体中部分父个体，作为下一代种群)和没有重串的稳态繁殖(在稳态繁殖的基础上，形成下一代新种群是，是其中的个体不重复) 2、交叉率及交叉操作:也可以称为基因重组，是遗传算法获取新的优良个体的最重要的手段，决定了遗传算法的全局搜索的能力。一般地，当随机产生的概率大于交叉率，遗传算法就会按照一定规律选择两个个体，执行交叉操作。一般取值范围为0.4~0.9。此外还有部分匹配交叉、顺序交叉、洗牌交叉等 3、变异:变异本身是一种局部随机搜索，使遗传算法具有局部的随机搜索能力，同时使得遗传算法保持种群的多样性，以防止出现非成熟收敛。一般地，随机产生的概率大于变异率就会触发变异操作，一般取值范围为0.001~0.1，如果大于0.5，遗传算法就退化为随机搜索，常见的变异法有实值变异法和二进制变异法 确定遗传算法的有关运行参数，包括群体规模(一般为20100)、迭代次数(一般为100500)、选择算子、交叉率、变异率等 初始化群体:初始化群体一般随机产生，初始值最好能在解空间中均匀采样(收敛速度比较快)，对于非二进制编码，还要考虑所生成的染色体是否在可行区域内 按照遗传策略，运用所选定的选择、交叉和变异算子作用于群体，生成下一代群体 10.判断群体性能是否能满足某一指标或是否完成预定迭代次数，不满足则返回9 未成熟收敛的防止 重新启动法 匹配策略 重组策略 替代策略 图论算法 一个图G是指一个二元组(V(G),E(G))，V(G)为顶点集，E(G)为边集 图的阶是指顶点数|V(G)|用v来表示；图的边数|E(G)|用ε来表示 最短路算法: 求赋权图中从给定点到其余顶点的最短路 求赋权图中任意两点间最短 Dijkstra和Floyd算法 Dijkstra算法:由任一顶点到其余顶点的最短路 分别求出顶点到相邻各点的最小值(绕路也要经过其它最短)，不相邻借助相邻 Floyd算法:任意两点之间的最小值，根据带权邻接矩阵不断插入点换去∞，得到两个矩阵 Floyd详解 避圈法和破圈法 决策树 将样本实例从根节点排列到某个叶子节点来对其进行分类 算法区别:属性选择；树的生长 算法: ID3算法 集合S相对于c个状态熵定义: Entropy(S)=−∑i=1cpilog⁡2piEntropy(S) = -\\sum_{i = 1}^{c}p_i\\log_2p_i Entropy(S)=−i=1∑c​pi​log2​pi​ 其中，pip_ipi​为子集合中第iii个属性值的样本数所占比例 信息增益: Gain(S,A)=Entorpy(S)−Entorpy(S,A)Gain(S, A) = Entorpy(S) - Entorpy(S, A) Gain(S,A)=Entorpy(S)−Entorpy(S,A) 信息熵的信息增益值 = 某一个划分上的信息熵 - 该划分上的期望信息熵 随机森林 ","link":"http://localhost:4001/post/mei-sai-suan-fa-ji-he/"},{"title":"[数字电子技术]门电路","content":"#半导体二极管门电路 ","link":"http://localhost:4001/post/shu-zi-dian-zi-ji-zhu-men-dian-lu/"},{"title":"[数字电子技术]数制和码制","content":"数制转换 二进制类型分为二进制数、八进制数和十六进制数 十进制类型分为十进制数和BCD码 二进制类型和十进制类型之间为真正意义上的数值转换，而类型内的转换为形式变换 八进制转十六进制，先二进制 八、十六进制由来 二进制数位压缩，增强可读性 十进制数位延展 原码、反码和补码 正数原、反、补码相等 负数反码为原码按位取反，补码为原码取反加一 BCD码 1位十进制数用4位二进制码元表示 BCD码是十进制数 8421码 明码，有权值码 余3码 8421码加3，明码，非权值码 2421码 有权值码，暗码(编码方案不唯一) 5421码 有权值码，明码(但5、6编码不唯一⭐️) 5211码 有权值码 可靠性代码 格雷码(单位距离码) 非权值码，相邻码元之间仅有一位码元，暗码 相邻代码变化平滑，无&quot;过渡噪声&quot; 奇偶校验码 信息位 + 校验位(仅有一位) 奇、偶校验码都是明码，生成的码也为明码 五位码元中，1的个数为奇数 五位码元中，1的个数为偶数 只能检奇数个错，不能纠错 #字符代码 狭义：数字、英文字母和一些专用符号 广义：为了表达数字、英文字母等字符，所设计的字符编码系统和编码方式 ASCII码：7位代码 ","link":"http://localhost:4001/post/shu-zi-dian-zi-ji-zhu-shu-zhi-he-ma-zhi/"},{"title":"[HAL]","content":"void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState) PinState: GPIO_PIN_RESET 低电平 GPIO_PIN_SET 高电平 void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) 电平反转 __weak void HAL_Delay(uint32_t Delay ) 参数1为1毫秒 只可实现毫秒级，微秒级自行通过__nop();编写 HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim) 使对应的定时器开始工作，但不开启中断服务 开启PWM前开启此函数 HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim) 打开定时器，并开启中断服务 void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim) 在HAL_TIM_IRQHandler对各个涉及中断的寄存器进行了处理之后，会自动调用中断回调函数 一般不在此进行编写操作 __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef*htim) 定时器回调函数，一般在此判断中断来源并执行相应的用户操作 一般在main.c中重写，并编写不同中断内容 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim == &amp;htim1){ } } HAL_StatusTypeDef HAL_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel) 启用PWM，并且不用编写HAL_TIM_Base_Start和HAL_TIM_Base_Start_IT函数 Prescaler(PSC):预分频系数 Counter Period(AutoReload Register/ARR):计数周期 Pulse:脉冲数(比较器参数) #define __HAL_TIM_SetCompare __HAL_TIM_SET_COMPARE #define __HAL_TIM_SET_COMPARE(__HANDLE__, __CHANNEL__, __COMPARE__) PWM比较 GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDEf* GPIOx, uint16_t GPIO_Pin) 高电平返回GPIO_PIN_SET，低电平返回GPIO_PIN_RESET void HAL_EXTI_IRQHandler(uint16_t GPIO_Pin) 对中断类型进行判断，并对涉及中断的寄存器进行处理，调用中断回调函数，一般不对此进行操作 __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) 中断回调函数，不需要编写任何前置函数，在此编写此次中断需执行的操作 ","link":"http://localhost:4001/post/hal/"},{"title":"[数字电子技术]逻辑代数","content":"基本运算 与或非 =与- | =或-非- | =与- 两输入异或、同或 2输入异或、同或互为反函数，非 异或(模2加) A ⊕ B=A · B' + A' · B 同或(&quot;符合&quot;逻辑/异或非) A ⊙ B=A · B + A' · B' A、B同，Y为1，不同为0 n输入异或 奇数1，输入出1 n输入异或、同或关系 n为偶数，异或、同或互为非关系，异或检奇，同或检偶 n为奇数，异或、同或相同，都检奇 奇偶校验码的生成与检测 生成与检测都用异或电路，正常输出检测信号为0 逻辑代数公式 序号 公式 序号 公式 1 0 · A = 0 10 1' = 0; 0' = 1 2 1 · A = A 11 1+A = 1 3 A · A = A 12 0+A = A 4 A · A' = 0 13 A+A = A 5 A · B = B 14 A+A' = 1 6 A · (B · C) = (A · B) · C 15 A+B = B+A 7 A · (B+C) = A · B + A · C 16 A+(B+C) = (A+B)+C 8 ⭐️(A · B)' = A' + B' 17 ⭐️ A+B · C = (A+B) · (A+C) 9 (A')' = A 18 ⭐️ (A+B)' = A' · B' 主要是非运算引起的不同 4与14互补，5和15交换律，6和16结合律，7和17分配律 实质是输出相同归类，8和18反演(De.Morgan)，真值表并不相同⭐️看起来太扯了,所以到底有没有运算有序呢 常用公式 序号 公式 21 A + A · B = A 22 A + A' · B = A+B 23 A · B+A · B' = A 24 A · (A+B) = A 25 A · B+A' · C+B · C = A · B+A' · C A · B+A' · C+BCD = A · B+A' · C 26 A · (A · B)' = A · B'; A' · (AB)' = A' 21、22、23为吸收定律，21为卡诺图原理 25为多余项定律，此定理难点为判断是否化为最简 基本定理 代入定理 可直接将一个逻辑式将一个式子中的一个变量全部替换 其实逻辑运算仍需要与普通运算一样遵照运算优先级，先括号，次并，最后或 对整个乘积项或者逻辑式求反，须对整个内容看作整体求反 反演定理 与变或，或变与，1变0，0变1，原变反，反变原，得到Y' 在进行反演时，仍须遵照运算优先级进行反演，从优先级最低开始反演，异或、同或优先级相同，低于与，高于或⭐️ 整体的非不变 对偶定理 一个式子经过与变或，或变与，1变0，0变1，得到对偶式Y^D，对偶式相等的两逻辑式相等 得到对偶就是反演的情况下不取反 n输入异或、同或始终互为同或 逻辑函数 五类基本形式 与或式 或非-与非式 或与式 或非-或非式 与或非式 真值表-&gt;逻辑函数式 找出真值表中使Y=1的输入变量取值的组合 每组输入变量取值对应一个乘积项，取值为1的变量取原，取值为0的变量取反 将这些乘积项或得到逻辑函数的一般形式 我猜的这是一般形式 逻辑函数标准形式 最小项与最大项 最小项：n个变量的乘积项中，每个变量均以原或反的形式出现一次 将原看作1，反看作0，得到最小项的二进制编号 在输入变脸的任何取值下必有一个最小项，而且仅有一个最小项的值为1 全体最小项之和为1 任意两个最小项的乘积为0 具有相邻性的两个最小项之和可以合并成一项并消去一对因子 这里是指不同取值情况下的一种情况 具有相邻性是指只有一个因子不同，如：A'BC' + ABC' = (A' + A)BC' = BC' 最大项： ","link":"http://localhost:4001/post/shu-zi-dian-zi-ji-zhu/"},{"title":"[ESC]电子调速器","content":"ElectronicSpeedControl 作用 电机供电 控制电机转速 电源输出功能：在信号线正负极之间，有5V电压输出，通过信号线为接收机供电，接收机再为舵机等设备供电 分类 有刷电调：使用机械转向器，改变电流方向 无刷电调：使用电子转向器，将直流电流转换为三相交流电流 BEC：免电池电路，具有分流供电的能力，可将电池的电压变为5V给飞控供电 OPTO光电电调：需单独给光电供电 选择 略大于电机最大效率电流，但不宜过大，以免影响电机寿命。一般一组电调中保留一个电调供电，其余选择OPTO光电电调 连接 输入线：最粗红黑线 输出线：有刷两根、无刷三根 信号线：最细线 ","link":"http://localhost:4001/post/escdian-zi-diao-su-qi/"},{"title":"[Java]","content":"数据类型 转换必须满足如下规则： 不能对boolean类型进行类型转换。 不能把对象类型转换成不相关类的对象。 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。⭐️ 转换过程中可能导致溢出或损失精度。 隐含强制类型转换 整数的默认类型是 int。 浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上 F 或 者 f。 将 boolean 转换为 int 唯一的方法： int myInt = myBoolean ? 1 : 0; 静态方法static 在不创建对象的情况下调用某个方法，就可以将这个方法设置为static，不能访问非静态成员/方法 非静态方法可以访问静态成员/方法 静态变量static 静态变量除了能在定义它的类内存取，还能直接以“类名.静态变量”的方式在其它类内使用。 static不能用来修饰局部变量 按位运算^ 相同取0，不同取1 A = 0011 1100 B = 0000 1101 A ^ B = 0011 0001 StringBuffer 和 StringBuiler 数组 增强型for循环 for(type element:array){}; 式中，type为数组array的类型；element是用来存放数组中元素的临时变量；array是待操作的数组。 作用是： 对数组中的数据依次进行存取。代码的功能是：每次从数组中取出元素[i]，并自动设定给p，不用判断是否超出了数组的长度。 优点： 每次从数组array中取数据，会自动赋给变量element，并且不用编译器判断是否超出了数组的长度。也即省去了标准for语句里的判决条件，如”i&lt;=array.length“。 equals和==区别 接口interface 接口中的方法会被隐式地指定为public abstract(只能是) 接口中只能有static和final变量 可多继承 jdk15环境变量 C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath C:\\Program Files\\Common Files\\Oracle\\Java\\javapath jdk8环境变量 JAVA_HOME CLASSPATH .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar ","link":"http://localhost:4001/post/java/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... <!-- more --> Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"http://localhost:4001/post/hello-gridea/"}]}